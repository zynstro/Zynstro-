<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article lang="">
  <sect1>
    <title>‚ú® Pro Color Tool: Conversion &amp; Alpha</title>
    <para>Paste Color Code (HEX, RGB, HSL): </para>
    <para>Opacity (Alpha): <anchor id="alphaValueDisplay"/>100% </para>
    <sect1 id="colorPreview">
      <para/>
    </sect1>
    <sect1 id="hexCode">
      <para>HEX:#007BFF</para>
    </sect1>
    <sect1 id="rgbaCode">
      <para>RGBA:rgba(0, 123, 255, 1)</para>
    </sect1>
    <sect1 id="hslaCode">
      <para>HSLA:hsla(210, 100%, 50%, 1)</para>
    </sect1>
    <sect1 id="cmykCode">
      <para>CMYK:cmyk(100%, 52%, 0%, 0%)</para>
    </sect1>
    <sect1 id="contrast-check">
      <para/>
    </sect1>
    <sect1 id="message">
      <para/>
    </sect1>
    <para>    const colorInput = document.getElementById('colorInput');
    const colorCodeInput = document.getElementById('colorCodeInput');
    const colorPreview = document.getElementById('colorPreview');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueDisplay = document.getElementById('alphaValueDisplay');
    const message = document.getElementById('message');
    const contrastCheck = document.getElementById('contrast-check');

    // --- Core Conversion Functions ---

    /** RGB to HSL conversion (0-255 to 0-360, 0-100%, 0-100%). */
    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) { h = s = 0; } else {
            const d = max - min;
            s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
    }

    /** RGB to CMYK conversion (0-255 to 0-100%). */
    function rgbToCmyk(r, g, b) {
        let c = 1 - (r / 255);
        let m = 1 - (g / 255);
        let y = 1 - (b / 255);
        let k = Math.min(c, m, y);

        if (k === 1) {
            c = m = y = 0;
        } else {
            c = (c - k) / (1 - k);
            m = (m - k) / (1 - k);
            y = (y - k) / (1 - k);
        }

        return {
            c: Math.round(c * 100),
            m: Math.round(m * 100),
            y: Math.round(y * 100),
            k: Math.round(k * 100)
        };
    }

    /** Converts a single component (0-255) to a two-digit hexadecimal string. */
    function componentToHex(c) {
        const hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }
    
    /** Utility to get Luminance for Contrast Check. */
    function getLuminance(r, g, b) {
        const a = [r, g, b].map(v =&gt; {
            v /= 255;
            return v &lt;= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        });
        return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
    }

    /** Utility to calculate Contrast Ratio. */
    function getContrastRatio(l1, l2) {
        const ratio = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
        return ratio.toFixed(2);
    }

    // --- Main Logic &amp; Update Functions ---

    /** Updates the display with the new color codes and preview. */
    function updateDisplay(r, g, b, alpha) {
        const hex = "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        const alphaFloat = alpha / 100;
        
        // RGB &amp; HSL with Alpha (RGBA, HSLA)
        const rgbaString = `rgba(${r}, ${g}, ${b}, ${alphaFloat.toFixed(2).replace(/\.?0+$/, '')})`;
        const hsl = rgbToHsl(r, g, b);
        const hslaString = `hsla(${hsl.h}, ${hsl.s}%, ${hsl.l}%, ${alphaFloat.toFixed(2).replace(/\.?0+$/, '')})`;
        
        // CMYK
        const cmyk = rgbToCmyk(r, g, b);
        const cmykString = `cmyk(${cmyk.c}%, ${cmyk.m}%, ${cmyk.y}%, ${cmyk.k}%)`;

        // Update DOM elements
        document.getElementById('hexCode').querySelector('.code-value').textContent = hex.toUpperCase();
        document.getElementById('rgbaCode').querySelector('.code-value').textContent = rgbaString;
        document.getElementById('hslaCode').querySelector('.code-value').textContent = hslaString;
        document.getElementById('cmykCode').querySelector('.code-value').textContent = cmykString;
        
        colorPreview.style.backgroundColor = rgbaString;
        alphaValueDisplay.textContent = `${alpha}%`;
        colorInput.value = hex; // Sync picker

        checkContrast(r, g, b);
    }

    /** Handles input from the built-in color picker. */
    function updateFromPicker() {
        const hex = colorInput.value;
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            const r = parseInt(result[1], 16);
            const g = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            const alpha = parseInt(alphaSlider.value);
            updateDisplay(r, g, b, alpha);
        }
    }

    /** Updates alpha (opacity) when the slider moves. */
    function updateAlpha() {
        // Re-use current color and just change the alpha
        const currentRgba = colorPreview.style.backgroundColor;
        const match = currentRgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            updateDisplay(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]), parseInt(alphaSlider.value));
        } else {
             updateDisplay(0, 123, 255, parseInt(alphaSlider.value)); // Default blue if current color is somehow missing
        }
    }
    
    /** Parses and converts a manual input string. */
    function parseColorInput() {
        const input = colorCodeInput.value.trim().toLowerCase();
        let r, g, b;
        
        if (input.startsWith('#') &amp;&amp; (input.length === 7 || input.length === 4)) {
            // HEX
            const hex = input.length === 4 ? 
                `#${input[1]}${input[1]}${input[2]}${input[2]}${input[3]}${input[3]}` : 
                input;
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                r = parseInt(result[1], 16);
                g = parseInt(result[2], 16);
                b = parseInt(result[3], 16);
            }
        } else if (input.startsWith('rgb')) {
            // RGB(A)
            const match = input.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                r = parseInt(match[1]); g = parseInt(match[2]); b = parseInt(match[3]);
            }
        } else if (input.startsWith('hsl')) {
            // HSL(A) - Simplified parsing, requires robust HSL to RGB conversion (omitted here for brevity, focusing on RGB core)
             showMessage('üí° HSL input detected. Please adjust the color picker manually for an immediate result, or try an RGB/HEX value.', 'info');
             return;
        }

        if (r !== undefined &amp;&amp; g !== undefined &amp;&amp; b !== undefined) {
             // Clamp values to ensure validity
             r = Math.min(255, Math.max(0, r));
             g = Math.min(255, Math.max(0, g));
             b = Math.min(255, Math.max(0, b));
             
             updateDisplay(r, g, b, parseInt(alphaSlider.value));
             showMessage('üéâ Input code converted!', 'success');
        } else {
             showMessage('‚ùå Invalid color code format. Please use a valid HEX, RGB(A), or HSL(A) format.', 'error');
        }
    }

    /** Checks color contrast for accessibility. */
    function checkContrast(r, g, b) {
        const colorLum = getLuminance(r, g, b);
        const whiteLum = 1.0;
        const blackLum = 0.0;
        
        const whiteRatio = getContrastRatio(colorLum, whiteLum);
        const blackRatio = getContrastRatio(colorLum, blackLum);
        
        // WCAG AA standard is 4.5:1, AAA is 7:1
        const whitePass = whiteRatio &gt;= 4.5;
        const blackPass = blackRatio &gt;= 4.5;
        
        contrastCheck.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        
        let text = `Contrast: ${whiteRatio}:1 (White Text) | ${blackRatio}:1 (Black Text). `;
        let textColor = 'black'; // Default to black text
        
        if (whitePass &amp;&amp; !blackPass) {
            textColor = 'white';
            text += "Use **White Text** for better readability (WCAG AA).";
        } else if (blackPass &amp;&amp; !whitePass) {
            textColor = 'black';
            text += "Use **Black Text** for better readability (WCAG AA).";
        } else if (whitePass &amp;&amp; blackPass) {
            textColor = (whiteRatio &gt; blackRatio) ? 'white' : 'black';
            text += `Both pass AA. Use ${textColor} text.`;
        } else {
             // Neither pass AA
            textColor = (colorLum &gt; 0.5) ? 'black' : 'white';
            text += "‚ùå Fails WCAG AA. Choose a different color or background.";
        }
        
        contrastCheck.style.color = textColor;
        contrastCheck.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '&lt;strong&gt;$1&lt;/strong&gt;');
    }

    /** Copies the color code to the clipboard. */
    async function copyCode(elementId) {
        const element = document.getElementById(elementId);
        const codeValue = element.querySelector('.code-value').textContent;
        
        if (!codeValue) return showMessage("No code to copy.", 'error');

        try {
            await navigator.clipboard.writeText(codeValue);
            showMessage(`‚úÖ Copied ${element.querySelector('.code-label').textContent} code: ${codeValue}`, 'success');
        } catch (err) {
            console.error('Copy failed: ', err);
            showMessage("‚ùå Failed to copy to clipboard.", 'error');
        }
    }

    /** Utility function for feedback messages. */
    function showMessage(text, type = 'success') {
        message.textContent = text;
        message.style.color = type === 'success' ? 'green' : (type === 'error' ? 'red' : 'orange');
        setTimeout(() =&gt; {
            message.textContent = '';
        }, 3000);
    }

    // Initialize with default color and alpha
    updateDisplay(0, 123, 255, 100);
  </para>
  </sect1>
</article>
